package com.saveourtool.save.cosv.service

import com.saveourtool.save.cosv.repository.AnyCosvSchema
import com.saveourtool.save.cosv.repository.CosvSchema
import com.saveourtool.save.cosv.repository.VulnerabilityMetadataRepository
import com.saveourtool.save.cosv.storage.CosvFileS3KeyManager
import com.saveourtool.save.entities.Organization
import com.saveourtool.save.entities.User
import com.saveourtool.save.entities.cosv.CosvFile
import com.saveourtool.save.entities.cosv.VulnerabilityMetadata
import com.saveourtool.save.entities.vulnerability.VulnerabilityLanguage
import com.saveourtool.save.entities.vulnerability.VulnerabilityStatus
import com.saveourtool.save.utils.getCurrentLocalDateTime
import com.saveourtool.save.utils.getLanguage

import org.springframework.http.HttpStatus
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import org.springframework.web.server.ResponseStatusException

import kotlinx.datetime.toJavaLocalDateTime

/**
 * Service for [VulnerabilityMetadata]
 */
@Service
class VulnerabilityMetadataService(
    private val vulnerabilityMetadataRepository: VulnerabilityMetadataRepository,
    private val cosvFileS3KeyManager: CosvFileS3KeyManager,
) {
    /**
     * @param cosvFile
     * @param cosv
     * @param user
     * @param organization
     * @return updated [VulnerabilityMetadata]
     */
    @Transactional
    fun createOrUpdate(
        cosvFile: CosvFile,
        cosv: AnyCosvSchema,
        user: User,
        organization: Organization?,
        isBulkUpload: Boolean,
    ): VulnerabilityMetadata {
        val metadata = vulnerabilityMetadataRepository.findByIdentifier(cosv.id)
            ?.let { existedMetadata ->
                validateMetadata(existedMetadata, cosv, user, organization)
                cosvFileS3KeyManager.setPrevCosvFile(cosvFile, existedMetadata)
                existedMetadata.updateBy(cosv, cosvFile, isBulkUpload)
            }
            ?: run {
                cosv.toNewMetadata(user, organization, cosvFile, isBulkUpload)
            }
        return vulnerabilityMetadataRepository.save(metadata)
    }

    /**
     * @param identifier
     * @return [VulnerabilityMetadata] for [identifier]
     */
    fun findByIdentifier(
        identifier: String,
    ): VulnerabilityMetadata? = vulnerabilityMetadataRepository.findByIdentifier(identifier)

    companion object {
        private fun CosvSchema<*, *, *, *>.toNewMetadata(
            user: User,
            organization: Organization?,
            cosvFile: CosvFile,
            isBulkUpload: Boolean,
        ) = VulnerabilityMetadata(
            identifier = id,
            summary = summary ?: "Summary not provided",
            details = details ?: "Details not provided",
            severityNum = severity?.firstOrNull()?.scoreNum?.toFloat() ?: 0f,
            modified = modified.toJavaLocalDateTime(),
            submitted = getCurrentLocalDateTime().toJavaLocalDateTime(),
            user = user,
            organization = organization,
            language = getLanguage() ?: VulnerabilityLanguage.OTHER,
            status = if (isBulkUpload) VulnerabilityStatus.APPROVED else VulnerabilityStatus.PENDING_REVIEW,
            latestCosvFile = cosvFile,
        )

        @Suppress("ThrowsCount")
        private fun validateMetadata(
            existedMetadata: VulnerabilityMetadata,
            cosv: CosvSchema<*, *, *, *>,
            user: User,
            organization: Organization?,
        ) {
            val newModified = cosv.modified.toJavaLocalDateTime()
            val errorPrefix: () -> String = {
                "Failed to upload COSV [${cosv.id}/${cosv.modified}]"
            }
            when {
                existedMetadata.modified >= newModified -> throw ResponseStatusException(
                    HttpStatus.BAD_REQUEST,
                    "${errorPrefix()}: existed entry has newer version (${existedMetadata.modified})",
                )
                existedMetadata.user.requiredId() != user.requiredId() -> throw ResponseStatusException(
                    HttpStatus.FORBIDDEN,
                    "${errorPrefix()} by userId=${user.requiredId()}: " +
                            "already existed in save uploaded by another userId=${existedMetadata.user.requiredId()}",
                )
                else -> existedMetadata.organization?.run {
                    if (requiredId() != organization?.requiredId()) {
                        throw ResponseStatusException(
                            HttpStatus.FORBIDDEN,
                            "${errorPrefix()} to organizationId=${requiredId()}: " +
                                    "already existed in save in another organizationId=${existedMetadata.organization?.requiredId()}",
                        )
                    }
                }
            }
        }

        private fun VulnerabilityMetadata.updateBy(
            entry: CosvSchema<*, *, *, *>,
            cosvFile: CosvFile,
            isBulkUpload: Boolean,
        ): VulnerabilityMetadata = apply {
            summary = entry.summary ?: "Summary not provided"
            details = entry.details ?: "Details not provided"
            severityNum = entry.severity?.firstOrNull()
                ?.scoreNum
                ?.toFloat() ?: 0f
            modified = entry.modified.toJavaLocalDateTime()
            latestCosvFile = cosvFile
            if (!isBulkUpload) {
                status = VulnerabilityStatus.PENDING_REVIEW
            }
        }
    }
}
