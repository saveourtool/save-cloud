package com.saveourtool.save.backend.service.vulnerability

import com.saveourtool.save.backend.repository.vulnerability.VulnerabilityDescriptionRepository
import com.saveourtool.save.backend.repository.vulnerability.VulnerabilityProjectRepository
import com.saveourtool.save.backend.repository.vulnerability.VulnerabilityRepository
import com.saveourtool.save.entities.vulnerabilities.Vulnerability
import com.saveourtool.save.entities.vulnerabilities.VulnerabilityDescription
import com.saveourtool.save.entities.vulnerabilities.VulnerabilityProject
import com.saveourtool.save.entities.vulnerability.VulnerabilityDto
import com.saveourtool.save.filters.VulnerabilityFilter
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import java.time.LocalDateTime

/**
 * A service that provides `Vulnerability`
 */
@Service
@Transactional(readOnly = true)
class VulnerabilityService(
    private val vulnerabilityRepository: VulnerabilityRepository,
    private val vulnerabilityDescriptionRepository: VulnerabilityDescriptionRepository,
    private val vulnerabilityProjectRepository: VulnerabilityProjectRepository,
) {
    /**
     * @param name name of vulnerability
     * @return vulnerability by name
     */
    fun findByName(name: String) = vulnerabilityRepository.findByName(name)

    /**
     * @return all vulnerabilities
     */
    fun findAll(): List<Vulnerability> = vulnerabilityRepository.findAll()

    /**
     * @param filters filters for vulnerability
     * @return list of vulnerabilities with that match [filters]
     */
    fun getFiltered(filters: VulnerabilityFilter): List<Vulnerability> = if (filters.prefixName.isBlank()) {
        vulnerabilityRepository.findAll()
    } else {
        vulnerabilityRepository.findByNameStartingWith(filters.prefixName)
    }

    /**
     * @param name name of vulnerability
     * @return vulnerability dto by name with description
     */
    fun getVulnerabilityWithDescriptionByName(name: String): VulnerabilityDto {
        val description = vulnerabilityDescriptionRepository.findByVulnerabilityName(name)?.description.orEmpty()
        return vulnerabilityRepository.findByName(name)?.toDtoWithDescription(description) ?: VulnerabilityDto.empty
    }

    /**
     * @param vulnerabilityDto dto of new vulnerability
     */
    @Transactional
    fun save(vulnerabilityDto: VulnerabilityDto) {
        val number = vulnerabilityRepository.findMaxId() + 1
        val name = "SOTV-${LocalDateTime.now().year}-$number"

        val vulnerability = Vulnerability(
            name = name,
            progress = 0,
            projects = emptyList()
        )
        val vulnerabilityNew = vulnerabilityRepository.save(vulnerability)
        val description = VulnerabilityDescription(
            vulnerability = vulnerabilityNew,
            description = vulnerabilityDto.description.orEmpty(),
        )
        vulnerabilityDescriptionRepository.save(description)

        val vulnerabilityProjects = vulnerabilityDto.projects.map { dto ->
            VulnerabilityProject(
                name = dto.name,
                url = dto.url,
                isOpenSource = dto.isOpenSource,
                vulnerability = vulnerability,
            )
        }
        vulnerabilityProjectRepository.saveAll(vulnerabilityProjects)
    }
}
